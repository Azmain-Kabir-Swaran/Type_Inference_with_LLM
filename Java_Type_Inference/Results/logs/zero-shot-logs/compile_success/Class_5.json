{
    "file": "/home/azmain/GitHub Codes/Type_Inference_with_LLM/Java_Type_Inference/snippets_for_test/all-zero-shot/Class_5.java",
    "java_code": "/*\n Date: 1/19/17\n URL: http://stackoverflow.com/questions/109383/sort-a-mapkey-value-by-values-java\n */\npackage common_JDK;\nimport java.util.LinkedHashMap;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.LinkedList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.Map;\n\npublic class Class_5\n{\n    public static <K, V extends Comparable<? super V>> Map<K, V> \n        sortByValue( Map<K, V> map )\n    {\n        List<Map.Entry<K, V>> list =\n            new LinkedList<Map.Entry<K, V>>( map.entrySet() );\n        Collections.sort( list, new Comparator<Map.Entry<K, V>>()\n        {\n            public int compare( Map.Entry<K, V> o1, Map.Entry<K, V> o2 )\n            {\n                return (o1.getValue()).compareTo( o2.getValue() );\n            }\n        } );\n\n        Map<K, V> result = new LinkedHashMap<K, V>();\n        for (Map.Entry<K, V> entry : list)\n        {\n            result.put( entry.getKey(), entry.getValue() );\n        }\n        return result;\n    }\n    public class main {\n        public void main_1() {\n            HashMap<String, Double> map = new HashMap<String, Double>();\n            ValueComparator bvc = new ValueComparator(map);\n            TreeMap<String, Double> sorted_map = new TreeMap<String, Double>(bvc);\n\n            map.put(\"A\", 99.5);\n            map.put(\"B\", 67.4);\n            map.put(\"C\", 67.4);\n            map.put(\"D\", 67.3);\n\n            System.out.println(\"unsorted map: \" + map);\n            sorted_map.putAll(map);\n            System.out.println(\"results: \" + sorted_map);\n        }\n    }\n\n    class ValueComparator implements Comparator<String> {\n        Map<String, Double> base;\n\n        public ValueComparator(Map<String, Double> base) {\n            this.base = base;\n        }\n\n        // Note: this comparator imposes orderings that are inconsistent with\n        // equals.\n        public int compare(String a, String b) {\n            if (base.get(a) >= base.get(b)) {\n                return -1;\n            } else {\n                return 1;\n            } // returning 0 would merge keys\n        }\n    }\n    \n}",
    "stdout": "",
    "stderr": "",
    "return_code": 0
}
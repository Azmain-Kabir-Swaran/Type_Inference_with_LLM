{
    "file": "/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java",
    "java_code": "/*\nDate: 1/19/17\nURL: http://stackoverflow.com/questions/62289/read-write-to-windows-registry-using-java\n*/\npackage common_JDK;\nimport java.lang.reflect.Method;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.prefs.Preferences;\n\npublic class Class_16 {\n  public static final int HKEY_CURRENT_USER = 0x80000001;\n  public static final int HKEY_LOCAL_MACHINE = 0x80000002;\n  public static final int REG_SUCCESS = 0;\n  public static final int REG_NOTFOUND = 2;\n  public static final int REG_ACCESSDENIED = 5;\n\n  private static final int KEY_ALL_ACCESS = 0xf003f;\n  private static final int KEY_READ = 0x20019;\n  private static final Preferences userRoot = Preferences.userRoot();\n  private static final Preferences systemRoot = Preferences.systemRoot();\n  private static final Class<? extends Preferences> userClass = userRoot.getClass();\n  private static final Method regOpenKey;\n  private static final Method regCloseKey;\n  private static final Method regQueryValueEx;\n  private static final Method regEnumValue;\n  private static final Method regQueryInfoKey;\n  private static final Method regEnumKeyEx;\n  private static final Method regCreateKeyEx;\n  private static final Method regSetValueEx;\n  private static final Method regDeleteKey;\n  private static final Method regDeleteValue;\n\n  static {\n    try {\n      regOpenKey = userClass.getDeclaredMethod(\"WindowsRegOpenKey\",\n          new Class[] { int.class, byte[].class, int.class });\n      regOpenKey.setAccessible(true);\n      regCloseKey = userClass.getDeclaredMethod(\"WindowsRegCloseKey\",\n          new Class[] { int.class });\n      regCloseKey.setAccessible(true);\n      regQueryValueEx = userClass.getDeclaredMethod(\"WindowsRegQueryValueEx\",\n          new Class[] { int.class, byte[].class });\n      regQueryValueEx.setAccessible(true);\n      regEnumValue = userClass.getDeclaredMethod(\"WindowsRegEnumValue\",\n          new Class[] { int.class, int.class, int.class });\n      regEnumValue.setAccessible(true);\n      regQueryInfoKey = userClass.getDeclaredMethod(\"WindowsRegQueryInfoKey1\",\n          new Class[] { int.class });\n      regQueryInfoKey.setAccessible(true);\n      regEnumKeyEx = userClass.getDeclaredMethod(  \n          \"WindowsRegEnumKeyEx\", new Class[] { int.class, int.class,  \n              int.class });  \n      regEnumKeyEx.setAccessible(true);\n      regCreateKeyEx = userClass.getDeclaredMethod(  \n          \"WindowsRegCreateKeyEx\", new Class[] { int.class,  \n              byte[].class });  \n      regCreateKeyEx.setAccessible(true);  \n      regSetValueEx = userClass.getDeclaredMethod(  \n          \"WindowsRegSetValueEx\", new Class[] { int.class,  \n              byte[].class, byte[].class });  \n      regSetValueEx.setAccessible(true); \n      regDeleteValue = userClass.getDeclaredMethod(  \n          \"WindowsRegDeleteValue\", new Class[] { int.class,  \n              byte[].class });  \n      regDeleteValue.setAccessible(true); \n      regDeleteKey = userClass.getDeclaredMethod(  \n          \"WindowsRegDeleteKey\", new Class[] { int.class,  \n              byte[].class });  \n      regDeleteKey.setAccessible(true); \n    }\n    catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private Class_16() {  }\n\n  /**\n   * Read a value from key and value name\n   * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n   * @param key\n   * @param valueName\n   * @return the value\n   * @throws IllegalArgumentException\n   * @throws IllegalAccessException\n   * @throws InvocationTargetException\n   */\n  public static String readString(int hkey, String key, String valueName) \n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    if (hkey == HKEY_LOCAL_MACHINE) {\n      return readString(systemRoot, hkey, key, valueName);\n    }\n    else if (hkey == HKEY_CURRENT_USER) {\n      return readString(userRoot, hkey, key, valueName);\n    }\n    else {\n      throw new IllegalArgumentException(\"hkey=\" + hkey);\n    }\n  }\n\n  /**\n   * Read value(s) and value name(s) form given key \n   * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n   * @param key\n   * @return the value name(s) plus the value(s)\n   * @throws IllegalArgumentException\n   * @throws IllegalAccessException\n   * @throws InvocationTargetException\n   */\n  public static Map<String, String> readStringValues(int hkey, String key) \n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    if (hkey == HKEY_LOCAL_MACHINE) {\n      return readStringValues(systemRoot, hkey, key);\n    }\n    else if (hkey == HKEY_CURRENT_USER) {\n      return readStringValues(userRoot, hkey, key);\n    }\n    else {\n      throw new IllegalArgumentException(\"hkey=\" + hkey);\n    }\n  }\n\n  /**\n   * Read the value name(s) from a given key\n   * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n   * @param key\n   * @return the value name(s)\n   * @throws IllegalArgumentException\n   * @throws IllegalAccessException\n   * @throws InvocationTargetException\n   */\n  public static List<String> readStringSubKeys(int hkey, String key) \n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    if (hkey == HKEY_LOCAL_MACHINE) {\n      return readStringSubKeys(systemRoot, hkey, key);\n    }\n    else if (hkey == HKEY_CURRENT_USER) {\n      return readStringSubKeys(userRoot, hkey, key);\n    }\n    else {\n      throw new IllegalArgumentException(\"hkey=\" + hkey);\n    }\n  }\n\n  /**\n   * Create a key\n   * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n   * @param key\n   * @throws IllegalArgumentException\n   * @throws IllegalAccessException\n   * @throws InvocationTargetException\n   */\n  public static void createKey(int hkey, String key) \n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    int [] ret;\n    if (hkey == HKEY_LOCAL_MACHINE) {\n      ret = createKey(systemRoot, hkey, key);\n      regCloseKey.invoke(systemRoot, new Object[] { new Integer(ret[0]) });\n    }\n    else if (hkey == HKEY_CURRENT_USER) {\n      ret = createKey(userRoot, hkey, key);\n      regCloseKey.invoke(userRoot, new Object[] { new Integer(ret[0]) });\n    }\n    else {\n      throw new IllegalArgumentException(\"hkey=\" + hkey);\n    }\n    if (ret[1] != REG_SUCCESS) {\n      throw new IllegalArgumentException(\"rc=\" + ret[1] + \"  key=\" + key);\n    }\n  }\n\n  /**\n   * Write a value in a given key/value name\n   * @param hkey\n   * @param key\n   * @param valueName\n   * @param value\n   * @throws IllegalArgumentException\n   * @throws IllegalAccessException\n   * @throws InvocationTargetException\n   */\n  public static void writeStringValue\n    (int hkey, String key, String valueName, String value) \n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    if (hkey == HKEY_LOCAL_MACHINE) {\n      writeStringValue(systemRoot, hkey, key, valueName, value);\n    }\n    else if (hkey == HKEY_CURRENT_USER) {\n      writeStringValue(userRoot, hkey, key, valueName, value);\n    }\n    else {\n      throw new IllegalArgumentException(\"hkey=\" + hkey);\n    }\n  }\n\n  /**\n   * Delete a given key\n   * @param hkey\n   * @param key\n   * @throws IllegalArgumentException\n   * @throws IllegalAccessException\n   * @throws InvocationTargetException\n   */\n  public static void deleteKey(int hkey, String key) \n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    int rc = -1;\n    if (hkey == HKEY_LOCAL_MACHINE) {\n      rc = deleteKey(systemRoot, hkey, key);\n    }\n    else if (hkey == HKEY_CURRENT_USER) {\n      rc = deleteKey(userRoot, hkey, key);\n    }\n    if (rc != REG_SUCCESS) {\n      throw new IllegalArgumentException(\"rc=\" + rc + \"  key=\" + key);\n    }\n  }\n\n  /**\n   * delete a value from a given key/value name\n   * @param hkey\n   * @param key\n   * @param value\n   * @throws IllegalArgumentException\n   * @throws IllegalAccessException\n   * @throws InvocationTargetException\n   */\n  public static void deleteValue(int hkey, String key, String value) \n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    int rc = -1;\n    if (hkey == HKEY_LOCAL_MACHINE) {\n      rc = deleteValue(systemRoot, hkey, key, value);\n    }\n    else if (hkey == HKEY_CURRENT_USER) {\n      rc = deleteValue(userRoot, hkey, key, value);\n    }\n    if (rc != REG_SUCCESS) {\n      throw new IllegalArgumentException(\"rc=\" + rc + \"  key=\" + key + \"  value=\" + value);\n    }\n  }\n\n  // =====================\n\n  private static int deleteValue\n    (Preferences root, int hkey, String key, String value)\n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {\n        new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) });\n    if (handles[1] != REG_SUCCESS) {\n      return handles[1];  // can be REG_NOTFOUND, REG_ACCESSDENIED\n    }\n    int rc =((Integer) regDeleteValue.invoke(root,  \n        new Object[] { \n          new Integer(handles[0]), toCstr(value) \n          })).intValue();\n    regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n    return rc;\n  }\n\n  private static int deleteKey(Preferences root, int hkey, String key) \n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    int rc =((Integer) regDeleteKey.invoke(root,  \n        new Object[] { new Integer(hkey), toCstr(key) })).intValue();\n    return rc;  // can REG_NOTFOUND, REG_ACCESSDENIED, REG_SUCCESS\n  }\n\n  private static String readString(Preferences root, int hkey, String key, String value)\n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {\n        new Integer(hkey), toCstr(key), new Integer(KEY_READ) });\n    if (handles[1] != REG_SUCCESS) {\n      return null; \n    }\n    byte[] valb = (byte[]) regQueryValueEx.invoke(root, new Object[] {\n        new Integer(handles[0]), toCstr(value) });\n    regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n    return (valb != null ? new String(valb).trim() : null);\n  }\n\n  private static Map<String,String> readStringValues\n    (Preferences root, int hkey, String key)\n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    HashMap<String, String> results = new HashMap<String,String>();\n    int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {\n        new Integer(hkey), toCstr(key), new Integer(KEY_READ) });\n    if (handles[1] != REG_SUCCESS) {\n      return null;\n    }\n    int[] info = (int[]) regQueryInfoKey.invoke(root,\n        new Object[] { new Integer(handles[0]) });\n\n    int count = info[0]; // count  \n    int maxlen = info[3]; // value length max\n    for(int index=0; index<count; index++)  {\n      byte[] name = (byte[]) regEnumValue.invoke(root, new Object[] {\n          new Integer\n            (handles[0]), new Integer(index), new Integer(maxlen + 1)});\n      String value = readString(hkey, key, new String(name));\n      results.put(new String(name).trim(), value);\n    }\n    regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n    return results;\n  }\n\n  private static List<String> readStringSubKeys\n    (Preferences root, int hkey, String key)\n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    List<String> results = new ArrayList<String>();\n    int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {\n        new Integer(hkey), toCstr(key), new Integer(KEY_READ) \n        });\n    if (handles[1] != REG_SUCCESS) {\n      return null;\n    }\n    int[] info = (int[]) regQueryInfoKey.invoke(root,\n        new Object[] { new Integer(handles[0]) });\n\n    int count  = info[0]; // Fix: info[2] was being used here with wrong results. Suggested by davenpcj, confirmed by Petrucio\n    int maxlen = info[3]; // value length max\n    for(int index=0; index<count; index++)  {\n      byte[] name = (byte[]) regEnumKeyEx.invoke(root, new Object[] {\n          new Integer\n            (handles[0]), new Integer(index), new Integer(maxlen + 1)\n          });\n      results.add(new String(name).trim());\n    }\n    regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n    return results;\n  }\n\n  private static int [] createKey(Preferences root, int hkey, String key)\n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    return  (int[]) regCreateKeyEx.invoke(root,\n        new Object[] { new Integer(hkey), toCstr(key) });\n  }\n\n  private static void writeStringValue \n    (Preferences root, int hkey, String key, String valueName, String value) \n    throws IllegalArgumentException, IllegalAccessException,\n    InvocationTargetException \n  {\n    int[] handles = (int[]) regOpenKey.invoke(root, new Object[] {\n        new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) });\n\n    regSetValueEx.invoke(root,  \n        new Object[] { \n          new Integer(handles[0]), toCstr(valueName), toCstr(value) \n          }); \n    regCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n  }\n\n  // utility\n  private static byte[] toCstr(String str) {\n    byte[] result = new byte[str.length() + 1];\n\n    for (int i = 0; i < str.length(); i++) {\n      result[i] = (byte) str.charAt(i);\n    }\n    result[str.length()] = 0;\n    return result;\n  }\n}",
    "stdout": "",
    "stderr": "/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:93: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:117: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:141: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:164: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:196: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:219: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:244: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:263: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:280: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:289: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:305: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:332: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:359: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n/home/azmain/code_for_compilation_test/zero-shot-temp-0.5/Class_16.java:368: error: cannot find symbol\n    InvocationTargetException \n    ^\n  symbol:   class InvocationTargetException\n  location: class Class_16\n14 errors\n",
    "return_code": 1
}
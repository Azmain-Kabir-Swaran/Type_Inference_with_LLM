{
    "file": "/home/azmain/GitHub Codes/Type_Inference_with_LLM/Java_Type_Inference/snippets_for_test/all-one-shot/Class_19.java",
    "java_code": "/*\nDate: 1/19/17\nURL: http://stackoverflow.com/questions/1519736/random-shuffling-of-an-array\n*/\npackage common_JDK;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\nclass Test\n{\n  public static void main(String args[])\n  {\n    int[] solutionArray = { 1, 2, 3, 4, 5, 6, 16, 15, 14, 13, 12, 11 };\n\n    shuffleArray(solutionArray);\n    for (int i = 0; i < solutionArray.length; i++)\n    {\n      System.out.print(solutionArray[i] + \" \");\n    }\n    System.out.println();\n    \n  }\n\n  // Implementing Fisher???Yates shuffle\n  static void shuffleArray(int[] ar)\n  {\n    // If running on Java 6 or older, use `new Random()` on RHS here\n    Random rnd = ThreadLocalRandom.current();\n    for (int i = ar.length - 1; i > 0; i--)\n    {\n      int index = rnd.nextInt(i + 1);\n      // Simple swap\n      int a = ar[index];\n      ar[index] = ar[i];\n      ar[i] = a;\n    }\n  }\n  protected static List<Integer> range(int n) {\n      return toList(new Range(n), new ArrayList<Integer>());\n  }\n\n  protected static <T> List<T> toList(Iterable<T> iterable) {\n      return toList(iterable, new ArrayList<T>());\n  }\n\n  protected static <T> List<T> toList(Iterable<T> iterable, List<T> destination) {\n      addAll(destination, iterable.iterator());\n\n      return destination;\n  }\n\n  protected static <T> void addAll(Collection<T> collection, Iterator<T> iterator) {\n      while (iterator.hasNext()) {\n          collection.add(iterator.next());\n      }\n  }\n\n  private static class Range implements Iterable<Integer> {\n      private int start;\n      private int stop;\n      private int step;\n\n      private Range(int n) {\n          this(0, n, 1);\n      }\n\n      private Range(int start, int stop) {\n          this(start, stop, 1);\n      }\n\n      private Range(int start, int stop, int step) {\n          this.start = start;\n          this.stop = stop;\n          this.step = step;\n      }\n\n      @Override\n      public Iterator<Integer> iterator() {\n          final int min = start;\n          final int max = stop / step;\n\n          return new Iterator<Integer>() {\n              private int current = min;\n\n              @Override\n              public boolean hasNext() {\n                  return current < max;\n              }\n\n              @Override\n              public Integer next() {\n                  if (hasNext()) {\n                      return current++ * step;\n                  } else {\n                      throw new NoSuchElementException(\"Range reached the end\");\n                  }\n              }\n\n              @Override\n              public void remove() {\n                  throw new UnsupportedOperationException(\"Can't remove values from a Range\");\n              }\n          };\n      }\n  }\n}",
    "stdout": "",
    "stderr": "",
    "return_code": 0
}